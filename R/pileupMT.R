#' Pileup the mitochondrial reads in a BAM, for variant calling or CN purposes. 
#'
#' If a BAM filename is given, but no ScanBamParam, scanMT(bam) will be called. 
#' Human mitochondrial genomes (GRCh37+ and hg38+) are fully supported, mouse
#' mitochondrial genomes (C57BL/6J aka NC_005089) are only somewhat supported.
#' 
#' @param bam       BAM (must be indexed!) file name or object with a @bam slot
#' @param sbp       optional ScanBamParam object (autogenerated if missing) 
#' @param pup       optional PileupParam object (autogenerated if missing)
#' @param ref       aligned reference mitogenome (default is rCRS/GRCh37+)
#' @param ...       additional args to pass on to the pileup() function
#'
#' @return          an MVRanges object, constructed from pileup results 
#' 
#' @import GenomicAlignments
#' @import GenomeInfoDb
#' @import Rsamtools
#' 
#' @examples
#' 
#' library(MTseekerData)
#' BAMdir <- system.file("extdata", "BAMs", package="MTseekerData")
#' BAMs <- paste0(BAMdir, "/", list.files(BAMdir, pattern=".bam$"))
#' bam <- BAMs[1]
#' 
#' sbp <- scanMT(bam)
#' show(sbp)
#' 
#' pu <- pileupMT(bam, ref="rCRS", sbp=sbp)
#' show(pu) 
#'
#' @export
#'
pileupMT <- function(bam, sbp=NULL, pup=NULL, ref=c("rCRS","GRCh37","GRCh38","hg38", "GRCm38","C57BL/6J","NC_005089","mm10"), ...) { 

  # can support multiple bams if we have sample names
  # perhaps it is worthwhile to autoextract them now

  if (is.null(sbp)) sbp <- scanMT(bam) 
  if (is.null(pup)) pup <- PileupParam(distinguish_strands=FALSE) 

  # turn this into a fn
  refSeqLengths <- c() 
  # data(mtRefs, package="MTseeker") # both
  data(rCRSeq, package="MTseeker") # human
  data(NC_005089seq, package="MTseeker") # mouse
  refSeqLengths["rCRS"] <- width(rCRSeq)
  refSeqLengths["GRCh38"] <- width(rCRSeq)
  refSeqLengths["hg38"] <- width(rCRSeq)
  refSeqLengths["GRCh37"] <- width(rCRSeq)
  refSeqLengths["NC_005089"] <- width(NC_005089seq)
  refSeqLengths["GRCm38"] <- width(NC_005089seq)
  refSeqLengths["mm10"] <- width(NC_005089seq) 
  refSeqLengths["C57BL/6J"] <- width(NC_005089seq)

  ref <- match.arg(ref)
  # scant support for other mitogenomes
  if (!ref %in% names(refSeqLengths)) {
    stop("Only the ", paste(names(refSeqLengths), collapse=" and "),
         " mitochondrial genome", 
         ifelse(length(refSeqLengths) > 1, "s are", " is"),
         " supported by pileupMT() at present.")
  } else { 
    pu <- pileup(file=bam, scanBamParam=sbp, pileupParam=pup, ...)
  }

  # simplify references down to the sane "mouse" or "human" mitogenomes 
  if (ref %in% c("C57BL/6J", "NC_005089", "GRCm38","mm10")) ref <- "mmMT"
  if (ref %in% c("hg38", "GRCh37", "GRCh38")) ref <- "rCRS" 

  refs <- DNAStringSet(c(rCRS=rCRSeq[['chrM']], 
                         NC_005089=NC_005089seq[['chrM']]))

  # will need to handle '-' and '+' separately 
  indels <- subset(pu, nucleotide %in% c('-', '+'))
  if (nrow(indels) > 0) {
    message("Warning: indels are not currently supported in pileupMT()")
  }
  # data(fpFilter_Triska, package="MTseeker") # for when they are... 
 
  # process results into VRanges fodder
  # may belong in a separate function...
  pu <- subset(pu, nucleotide %in% c('A','C','G','T'))
  pu$which_label <- NULL # confusing here 
  refseq <- factor(strsplit(as.character(rCRSeq[['chrM']]), '')[[1]],
                   levels=levels(pu$nucleotide))
  pu$ref <- refseq[pu$pos]
  pu$alt <- pu$nucleotide 
  pu$totalDepth <- .byPos(pu, "count")
  is.na(pu$alt) <- (pu$nucleotide == pu$ref)
  pu$altDepth <- ifelse(is.na(pu$alt), NA_integer_, pu$count) 
  pu$refDepth <- pu$totalDepth - .byPos(pu, "altDepth")
  pu$isAlt <- !is.na(pu$alt)
  pu$alleles <- .byPos(pu, "isAlt") + 1 
  columns <- c("seqnames","pos","ref","alt","totalDepth","refDepth","altDepth")
  gr <- keepSeqlevels(.puToGR(subset(pu, isAlt|alleles==1)[,columns]),
                      unique(pu$seqnames))
  seqinfo(gr) <- Seqinfo("chrM", length(refs[[ref]]), 
                         isCircular=TRUE, genome=ref)
  vr <- makeVRangesFromGRanges(.puToGR(subset(pu, isAlt|alleles==1)[,columns]))
  vr <- keepSeqlevels(vr, "chrM") 
  seqinfo(vr) <- seqinfo(gr)
  mvr <- MVRanges(vr, coverage=median(rowsum(pu$count, pu$pos)))
  sampleNames(mvr) <- base::sub(".bam", "", basename(bam))
  covg <- rep(0, length(refs[[ref]]))
  covered <- rowsum(pu$count, pu$pos)
  covg[as.numeric(rownames(covered))] <- covered 
  metadata(mvr)$coverageRle <- Rle(covg)
  metadata(mvr)$bam <- bam
  metadata(mvr)$sbp <- sbp
  metadata(mvr)$pup <- pup
  genome(mvr) <- ref
  return(mvr)
}


# helper fn
.byPos <- function(x, y) { 
  rowsum(as.numeric(x[,y]), as.character(x$pos), na.rm=1)[as.character(x$pos),]
}


# helper fn
.puToGR <- function(pu) { 
  makeGRangesFromDataFrame(pu, start.field="pos", end.field="pos", strand="*",
                           keep.extra.columns=TRUE)
}

